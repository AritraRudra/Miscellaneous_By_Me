package javapuzzlers.chapter3;

import java.io.UnsupportedEncodingException;

/*
 * Chapter 3 : Puzzlers with Character
 */
public class Abc {

	public static void main(String[] args) throws UnsupportedEncodingException {

		// ################ Puzzle 12 - Abc ################ //
		String letters = "ABC";
		char[] numbers = { '1', '2', '3' };
		System.out.println(letters + " easy as " + numbers);

		// Proper ways to do this are
		System.out.println(letters + " easy as " +String.valueOf(numbers));
		// Alternatively, you can break the System.out.println invocation in two to make use of the char[] overloading of println:
		System.out.print(letters + " easy as ");
		System.out.println(numbers);
		
		// This is different, invokes the wrong overloading of println!
		numbers = new char[] { '1', '2', '3' };	// Difference here
		System.out.print(letters + " easy as ");
		System.out.println(numbers); // Invokes println(Object)
		
		
		// ################ Puzzle 13 - Animal Farm ################ //
		/*
		 * 1. When using the string concatenation operator, always parenthesize
		 * nontrivial operands. 
		 * 2. compile-time constants of type String are interned
		 * [JLS 15.28]. In other words, any two constant expressions of type String that
		 * designate the same character sequence are represented by identical object
		 * references. If initialized with constant expressions, both pig and dog would
		 * indeed refer to the same object, but dog is not initialized with a constant
		 * expression. The language constrains which operations are permitted to appear
		 * in a constant expression [JLS 16.28], and method invocation is not among them.
		 */
		final String pig = "length: 10";
		final String dog = "length: " + pig.length();
		System.out.println("Animals are equal: "+ pig == dog);
		// Below one is the behaviour we wanted, but program is still broken. Your code should rarely, if ever, depend on the interning of string constants  		
		System.out.println("Animals are equal: "+ (pig == dog));	
		
		
		// ################ Puzzle 15 - Hello Whirled ################ //
		/*
		 * Unicode escapes must be well formed, even if they appear in comments.
		*/
		/**
		* Generated by the IBM IDL-to-Java compiler, version 1.0
		* from F:\TestRoot\apps\a1\<unicode here>units\include\PolicyHome.idl
		* Wednesday, June 17, 1998 6:44:40 oâ€™clock AM GMT+00:00
		*/
		System.out.print("Hell");
		System.out.println("o world");
		
		
		// ################ Puzzle 18 - String Cheese ################ //
		/*
		 * 1. When translating between char sequences and byte sequences, you can and usually should specify a charset explicitly. 
		 * 2. every time you translate a byte sequence to a String, you are using a charset, whether you specify it
		 * explicitly or not. If you want your program to behave predictably, specify a charset each time you use one.
		 */
		byte[] bytes = new byte[256];
		for (int i = 0; i < 256; i++)
			bytes[i] = (byte) i;
		String str = new String(bytes);
		for (int i = 0, n = str.length(); i < n; i++)
			System.out.print((int) str.charAt(i) + " ");
		System.out.println();
		str = new String(bytes, "ISO-8859-1");	// Specify charsetName always
		for (int i = 0, n = str.length(); i < n; i++)
			System.out.print((int) str.charAt(i) + " ");
		System.out.println();
		
		
	}

}
